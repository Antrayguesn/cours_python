= La mission de César
:imagesdir: images
:source-highlighter: rouge

Jules César vous donne une mission pour son siège d'Alesia

Mettre au point un algorithme de chiffrement pour communiquer avec ses troupes.

Le premier message qu'il vous donne à envoyé est le suivant : 

....
Légionnaire, vous êtes chargé de la mission cruciale de d'explorer les environs d'Alésia pour recueillir des renseignements sur les mouvements et les effectifs des forces gauloises. Soyez vigilant, agissez avec détermination et rappelez-vous que le destin de Rome repose sur vos épaules. Que la fortune vous guide.
....

== Le chiffre de César

Objectif du chiffre de César

* Rendre confidentiel un texte par décalage des lettres de l'alphabet.
* La clé est le décalage choisi

Chiffrement symétrique:

* La clé est une variable de l'algorithme qui le rend secret
* Le chiffrement et le déchiffrement s'effectue avec la même clé

== Implémentation du chiffre de César

image::cesar2.png[Cesar] 


Chiffrement :

* Choisir un décalage
* Additioner ce décalage à la position de la lettre dans l'alphabet
** Si la nouvelle position est supérieur à 26, alors on revient au début (24 + 10 = 8)
* Convertir la nouvelle position avec la lettre corespondante dans l'alphabet

Déchiffrement :

* Soustraire la clé à la position de la lettre dans l'alphabet
** Si la nouvelle position est supérieur à 26, alors on retourne à la fin (6 - 10 = 22)
* Convertir la nouvelle position avec la lettre corespondante dans l'alphabet

== Exemple du chiffre de César

* Clair :

....
Python (prononcé /pi.tɔ̃/) est un langage de programmation interprété, multiparadigme et multiplateformes. Il favorise la programmation impérative structurée, fonctionnelle et orientée objet. Il est doté d'un typage dynamique fort, d'une gestion automatique de la mémoire par ramasse-miettes et d'un système de gestion d'exceptions ; il est ainsi  imilaire à Perl, Ruby, Scheme, Smalltalk et Tcl.
....

* Chiffré (décalage à 6):
....
Veznut (vxututik /vo.zɔ̃/) kyz at rgtmgmk jk vxumxgssgzout otzkxvxkzk, sarzovgxgjomsk kz sarzovrgzkluxsky. Or lgbuxoyk rg vxumxgssgzout osvkxgzobk yzxaizaxkk, lutizouttkrrk kz xoktzkk uhpkz. Or kyz juzk j'at zevgmk jetgsowak luxz, j'atk mkyzout gazusgzowak jk rg sksuoxk vgx xgsgyyk-sokzzky kz j'at yeyzksk jk mkyzout j'kdikvzouty ; or kyz gotyo  osorgoxk g Vkxr, Xahe, Yinksk, Ysgrrzgrq kz Zir. 
....

//TP 1.1

== TP 1.1 : Jouer avec l'entrée standard

NOTE: 15 min

. Enregistrer une chaine de caractère provenant de l'entrée standard
. Afficher chaque lettre du message

---

* `input()` : Pour récuperer la saisie en chaine de caractère
* `print(str)` : Pour afficher une valeur


// TP 1.2

== TP 1.2 : Chiffre de César !

NOTE: 1 heure

. Ecrire un script qui prend en entrée un message et un nombre.
. Convertir chaque en lettre en `ASCII`
** Determiner si la lettre en minuscule ou majascule
. Décaler chaque lettre du message du nombre saisi
** Si la valeur n'est pas une lettre ([A-Za-z]) ne pas la modifier
. Convertir le nouveau code `ASCII` en lettre
. Afficher la nouvelle chaine

---

A savoir :

* `int(variable)` : Convertie la variable passé en `int`
* `ord(caractere)` : Retourne le code `ASCII` du caractère passé en paramètre
* `chr(codeAscii)` : Retourne la lettre corespondant au code `ASCII`
* 65 = A en `ASCII` / 97 = a en `ASCII`

---

Pensez à utiliser des constantes:

[source, python]
----
DEBUT_MAJUSCULE = 65
DEBUT_MINUSCULE = 97

FIN_MAJUSCULE = DEBUT_MAJUSCULE + 26
FIN_MINUSCULE = DEBUT_MINUSCULE + 26
----

Construire une chaine de caractère:

[source, python]
----
ma_chaine = ""

for i in range(10):
  ma_chaine += str(i)

print(ma_chaine)
0123456789
----

== TP 1.3 : Programmation fonctionnelle !

NOTE: 30 min

. Télécharger le code suivant : 
. Identifier les différentes fonction du code
. Ranger le code ecrit dans des fonctions
. Ecrire la fonction `dechiffrer_cesar(message: str, cle: str) -> str`


.Fonctions à trouver
[%collapsible]
====
* ```est_majuscule(lettre: str) -> str```
* ```alphabet_to_ascii(lettre: str, typeLettre: int) -> str```
* ```ascii_to_alphabet(lettre: str) -> (str, int) # Retourne le type de lettre majuscule ou minuscule```
* ```decaler_lettre(lettre: str, decalage: int) -> str```
* ```chiffrer_cesar(message: str, cle: int) -> str```
* ```dechiffrer_cesar(message: str, cle: str) -> str:```
====

Pour tester :

[source, bash]
----
python3 -i tp1_3.py
>>> chiffre = chiffrer_cesar(message_saisi, clef)
>>> chiffre
...
>>> dechiffrer_cesar(chiffre, clef)
----

=== A savoir

==== Fonction

Une fonction est un bloc de code réutilisable qui effectue une tâche spécifique

* Elle peut prendre des paramètre
* Elle peut retourner une valeur

===== Synatxe

[source, python]
----
def ma_fonction():
  print("Ceci est une fonction")

def ma_fonction_avec_arguments(arg1: int, arg2: int):
  print("Ceci est une fonction avec des arguments : ", arg1, arg2)

def ma_fonction_avec_arguments(arg1: int, arg2: int = None):
  print("Ceci est une fonction avec des arguments : ", arg1, arg2)

def ma_fonction_qui_retourne_une_valeur() -> str:
  return "Je suis le retour d'une fonction"
----

Appeller une fonction :

[source, python]
----
>>> ma_fonction()
Ceci est une fonction
>>> ma_fonction_avec_arguments(2, 3) # Arguments positionnels
Ceci est une fonction avec des arguments : 2 3
>>> ma_fonction_avec_arguments(arg2=1, arg1=8) # Argument par mot-clé
Ceci est une fonction avec des arguments : 8 1
>>> ma_fonction_qui_retourne_une_valeur()
"Je suis le retour d'une fonction"
----

== TP 1.4 : Légionnaire !

NOTE: 20 min

* Entrée du message par fichier et non entrée standard
* Sortie du message par fichier et non entrée standard

---

. Ecrire le message que vous à confier Jules César dans un fichier
. Ecrire la fonction `lire_message(cheminMessage: str) -> str` qui retourne le contenu du fichier ciblé par le chemin en paramètre
. Ecrire la fonction `ecrire_message(message: str) -> None` qui ecrit le message dans un fichier nommé `message_chiffre.txt`

Test : 

[source, bash]
----
python3 -i tp1_3.py
>>> message_saisi = lire_message("message.txt")
>>> chiffre = chiffrer_cesar(message_saisi, clef)
>>> ecrire_message(chiffre)
----

=== A savoir

==== Les fichiers

Ouvrir un fichier et le lire ligne par ligne :

[source, python]
----
mon_fichier = open("fichier", "r")

for ligne in mon_fichier:
  print(ligne)

mon_fichier.close()
----

Avec un contexte manager : 

[source, python]
----
with open("fichier", "r") as mon_fichier: # Le fichier est ouvert
  for ligne in mon_fichier:
    print(ligne)
# Le fichier est fermé
----


Lire le contenu entier du fichier :

[source, python]
----
with open("fichier", "r") as mon_fichier:
  print(mon_fichier.read()) # Retourne tout le fichier
----

https://docs.python.org/fr/3.6/library/functions.html#open

== TP 2 : Vercingétorix

Vercingétorix trouve sur un soldat romain l'étrange message suivant : 

....
Téoqwvviqzm, dwca êbma kpizoé lm ti uqaaqwv kzckqitm xzwbéomz tm kwvdwq lm zidqbiqttmumvb mv xzwdmvivkm lm Omzowdqi, tm kwvdwq xiaamzi à ti bwujmz lm ti vcqb. Awgmh dqoqtivb, ioqaamh idmk lébmzuqvibqwv mb zixxmtmh-dwca ycm tm lmabqv lm Zwum zmxwam acz dwa éxictma. Ycm ti nwzbcvm dwca ocqlm.
....

Il apprend que vous êtes le créateur de la méthode de chiffrement, il vous capture pour decrypter le message !

---

=== Implémentation

La methode de decryptage que nous allons implémenter va comparer la fréquence des lettres dans une langue donnée avec la fréquence des lettres du message chiffré.

Pour trouver la fréquence des lettres d'un langue, nous allons parcourir un livre.

Nous prendrons Vingt Milles Lieux sous les Mers : https://www.gutenberg.org/cache/epub/5097/pg5097.txt

On compare les lettres les plus fréquentes du message chiffrée avec ce de la langue. La comparaison des deux letrtes nous donne une clé probable. 

On attribue un classment aux clés trouvée sur le nombre d'occurence de la lettre chiffrée

Le calcul se fait sur une base 26

[source, python]
----
frequence_lettre_message = ['w', 'k', 'f', 'm', 'a', 'j']
frequence_lettre_langue  = ['e', 's', 'a', 'n', 'i', 't']
----

....

cle_probable = (frequence_lettre_message - frequence_lettre_langue) % 26

w = 22 e = 4
k = 10 s = 18
f = 5  a = 0
n = 13 m = 12

(w - e) % 26

(22 - 4)  % 26 = 18
(10 - s)  % 26 = 18
(5 - 0)   % 26 = 5
(13 - 12) % 26 = 1
...

....

== TP 2.1 : Analyse de langue

NOTE: 20 + 20 minutes

. Récuperer le fichier : https://www.gutenberg.org/cache/epub/5097/pg5097.txt
. Ecrire une fonction `occurence_lettre_livre(cheminLivre: str)`
** Elle prend en paramètre le chemin vers un livre
** Elle retourne le nombre d'occurence de lettre dans ce chiffier
. Compter le nombre de d'occurence de chaque lettre du livre
** Mettre chaque lettre en minuscule

Test :

[source,python]
----
print(occurence_lettre_livre("livres/vmlslm.txt"))
----

---

* Bien étudier les différentes collections
* Tester avec l'interpréteur
* `str.lower()` Pour mettre en minuscule une chaîne de caractère

.Indice
[%collapsible]
====
[source,python]
----
>>> from collections import Counter
>>> Counter("Je suis un super message")
Counter({'s': 5, 'e': 4, ' ': 4, 'u': 3, 'J': 1, 'i': 1, 'n': 1, 'p': 1, 'r': 1, 'm': 1, 'a': 1, 'g': 1})
----
====

=== A savoir

==== Collections

Les collections indexent des éléments pouvant être parcouru de manière itératives

En python, les éléments des collections ne sont pas typé

* https://docs.python.org/3/tutorial/datastructures.html
* https://docs.python.org/3/library/collections.html

==== Bibliothéque

Un ensemble de fonctions s'appelle une librairie.

Les librairies peuvent être importer dans des scripts.

Python posséde une bibliothéque standard qui étends ces possibilités.

* https://docs.python.org/fr/3/library/index.html

Pour les importer :

[source, python]
----
import time # Importer toute la librairie

print(time.time())

from time import time # Import de la fonction time()

print(time())
----

Les imports se trouvent en haut du fichier


== TP 2.2 Decrypter le chiffre le Cesar

NOTE: 1 heure

* Ecrire une fonction `decrypter_cesar(message: str) -> list`
** Cette fonction prend en paramètre un message
** Elle retourne une liste des 3 clés les plus probable classé par probabilité
* 
* Afficher les messages dechiffrer à l'aide des 3 clés

Test :

[source, python]
----
message = lire_message("message_chiffre.txt")

cles = decrypter_cesar(message, occurence_lettre_livre("livres/vmlslm.txt"))

for c in cles:
  print(dechiffrer_cesar(message, c))
----

=== A savoir

==== Gestion des erreurs

try 

except

liste des exception

==== Dictionnaire

[source, python]
----
score_cle_probable = {}


score_cle_probable[cle_probable] = 12

score_cle_probable[cle_probable] += 1

mon_dictionnaire = {}

if cle_probable in mon_dictionnaire: # True si la clé existe sinon False
  mon_dictionnaire[cle_probable] += 1
else:
  mon_dictionnaire[cle_probable] = 0

try:
  mon_dictionnaire[cle_probable] += 1
except KeyError:
  mon_dictionnaire[cle_probable] = 0
----

==== Counter

[source, python]
----
frequence_lettre_langue = occurence_lettre_livre("livres/vmlslm.txt")
frequence_lettre_langue.most_common() # Retourne une liste des occurences triées par occurences

+frequence_lettre_langue # Retourne un Counter sans les éléments vide ou à zero
-frequence_lettre_langue # Retourne un Counter avec uniquement les éléments vide ou à zero
----

== TP 3 : Hasta siempre !

2000 ans après vos exploits auprès de Jules César, votre nom se fait connaître à Cuba où une révolution est en cours.

Comme nous l'avons demontrée, le chiffre de César n'est pas fiable, il est facilement decryptable.

Vous êtes contacté par Che Guevara pour mettre en place un algorithme plus sécurisé et de pouvoir transmettre la clé simplement.

Vous vous inspirer des conceptes du `Chiffre de Vernam` ou du `Masque jetable`:
* La clé doit être une suite de caractères au moins aussi longue que le message à chiffrer.
* Les caractères composant la clé doivent être choisis de façon totalement aléatoire.
* Chaque clé, ou masque, ne doit être utilisée qu'une seule fois (d'où le nom de masque jetable).

Pour répondre à ces principes et au besoin, vous decidez :
* La clé sera récuperé depuis un livre
* La clé sera récuperé après un nombre de caractère aléatoire
* Le nombre de caractère aléatoire est compris entre 0 et la fin du fichier - taille du message
* La clé sera uniquement composé de lettre


== TP 3.1 : Drole de types

NOTE: 1 heure

[plantuml, format="svg", id="classMessage"]
----
class Message {
{field} Chiffrement algorithme_chiffrement
{field} str message

__init__(algorithme_chiffrement: Chiffrement)
{method} chiffrer() -> str
{method} dehiffrer() -> str
message_from_fichier(cheminMessage: str)
ecrire_dans_fichier(cheminMessage: str)
}

Chiffrement o-- Message

Chiffrement <|-- ChiffrementDecalage

ChiffrementDecalage <|-- Cesar
@enduml
----

* Dans le fichier `chiffrement.py`, écrire la classe `Chiffrement`
** 



* Dans le fichier `message.py`, ecrire la classe `Message`


** chiffrer()

== TP 3.2 : L'héritage


[plantuml, format="svg", id="classMessageChiffrement"]
----
@startuml Chiffrement
class Chiffrement {

__init__(clef: object)
{method} chiffrer(message: str) -> str
{method} dehiffrer(message: str) -> str
}

class ChiffrementDecalage {
  _est_majuscule(lettre: str) -> int
  _est_lettre(lettre: str) -> bool
  alphabet_to_ascii(position_lettre: int, typeLettre: int) -> str
  ascii_to_alphabet(lettre: str) -> (str, int)
}

class Cesar {

}

class Message {
{field} Chiffrement algorithme_chiffrement
{field} str message

__init__(algorithme_chiffrement: Chiffrement)
{method} chiffrer() -> str
{method} dehiffrer() -> str
message_from_fichier(cheminMessage: str)
ecrire_dans_fichier(cheminMessage: str)
}

Chiffrement o-- Message

Chiffrement <|-- ChiffrementDecalage

ChiffrementDecalage <|-- Cesar
@enduml
----